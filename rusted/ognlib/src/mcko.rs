//! Russian text below
//! Данный код решает номера из диагнстики МЦКО - для московских школьников.
//! Наверное, лучше это всё решать на питоне, но Rust достаточно высокоуровненвый, чтобы решать эти номера.
//! Номера взяты из комплекта:
//! https://mcko.ru/uploads/documents/informatika_-10-klass_komplekt_1-91f3befffaba6eed.zip
//! Здесь приведены решения лишь 3 номеров, так как остальные либо вообще не решаются программированием,
//! либо гораздо быстрее решаются руками.
//! Но номер 10, например, не был решён, так как строка ввода слишком длинная для Rust...
//! Возможно данная проблема имеет решение, но мне лень искать инфу, да и вручную номер решается спокойно.

/// #### Номер 2:
/// Автомат обрабатывает натуральное число N по следующему алгоритму:
/// 1) Строится двоичная запись числа N.
/// 2) К полученной записи дописываются разряды по следующему принципу:
/// если число чётное, то справа дописывается 10, если нечётное – слева
/// дописывается 1 и справа 00.
/// 3) Результат переводится в десятичную систему и выводится на экран.
/// В результате работы автомата на экране появилось число, большее 107.
/// Для какого наименьшего N данная ситуация возможна? В ответе найденное
/// число N запишите в десятичной системе.
///
/// # Ответ
///
/// ```
/// use ognlib::mcko::n2;
///
/// assert_eq!(n2(1), 11);
/// ```

pub fn n2(n: u16) -> u16 {
    use super::num::radix::StringRadix;

    let mut num = StringRadix::from(&n.to_string()).to_radix(2);

    if n % 2 == 0 {
        num.number = format!("{}10", num.number);
    } else {
        num.number = format!("1{}00", num.number);
    }

    let num = num.to_int_radix(10);

    if num.number > 107 {
        n
    } else {
        n2(n + 1)
    }
}

/// #### Номер 11:
/// Операнды арифметического выражения записаны в системе счисления с основанием 12.
/// 154x3_12 + 1x365_12
/// В записи чисел переменной x обозначена неизвестная цифра из алфавита
/// двенадцатеричной системы счисления. Определите значение x, при котором
/// значение данного арифметического выражения кратно 13. Для найденного
/// значения x вычислите частное от деления значения арифметического
/// выражения на 13 и укажите его в ответе в десятичной системе счисления.
/// Основание системы счисления в ответе указывать не нужно.
///
/// # Ответ
///
/// ```
/// use ognlib::mcko::n11;
///
/// assert_eq!(n11(), 4340);

pub fn n11() -> usize {
    const RADIX: &[char] = &['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B'];

    let (mut num1, mut num2): (usize, usize) = (0, 0);
    for num in RADIX {
        (num1, num2) = (
            usize::from_str_radix(&format!("154{num}3"), 12).unwrap(),
            usize::from_str_radix(&format!("1{num}365"), 12).unwrap(),
        );
        if (num1 + num2) % 13 == 0 {
            break;
        }
    }
    (num1 + num2) / 13
}

/// #### Номер 12:
/// В файле 12.txt содержится последовательность целых чисел. Элементы
/// последовательности могут принимать целые значения от –100 000 до 100 000
/// включительно. Пусть N – минимальное число в последовательности,
/// НЕ кратное 15. Определите количество пар элементов последовательности,
/// в которых оба числа кратны N. В ответе запишите количество найденных пар,
/// затем максимальную из сумм элементов таких пар. В данной задаче под парой
/// подразумевается два идущих подряд элемента последовательности.
///
/// # Ответ
///
/// ```
/// use ognlib::mcko::n12;
///
/// assert_eq!(n12(), (157, 176024));
/// ```

pub fn n12() -> (usize, i32) {
    use std::{fs::File, io::Read};

    let mut file = File::open("12.txt").unwrap();

    let mut data: Vec<i32> = Vec::new();
    let (mut min, mut count, mut max, mut contents) = (100_000, 0, 0, String::new());

    file.read_to_string(&mut contents).unwrap();

    for i in contents.lines() {
        let num = i.parse::<i32>().unwrap();
        data.push(num);
        if num < min && num % 15 != 0 {
            min = num;
        }
    }
    for i in 0..data.len() - 1 {
        let (t1, t2) = (data[i], data[i + 1]);
        if t1 % min == 0 && t2 % min == 0 {
            count += 1;
            if t1 + t2 > max {
                max = t1 + t2;
            }
        }
    }
    (count, max)
}
